% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulation_functions.R
\name{s_generate_data_mars}
\alias{s_generate_data_mars}
\title{Generate non linear response and test and training sets for non-linear
simulation study}
\usage{
s_generate_data_mars(p, X, beta, binary_outcome = FALSE, truemodule, nActive,
  cluster_distance = c("corr", "corr0", "corr1", "tom", "tom0", "tom1",
  "diffcorr", "difftom", "corScor", "tomScor", "fisherScore"), n, n0,
  include_interaction = F, signal_to_noise_ratio = 1,
  eclust_distance = c("fisherScore", "corScor", "diffcorr", "difftom"),
  cluster_method = c("hclust", "protoclust"), cut_method = c("dynamic",
  "gap", "fixed"), distance_method = c("euclidean", "maximum", "manhattan",
  "canberra", "binary", "minkowski"), n_clusters,
  agglomeration_method = c("complete", "average", "ward.D2", "single",
  "ward.D", "mcquitty", "median", "centroid"), nPC = 1, K.max = 10,
  B = 10)
}
\arguments{
\item{p}{number of genes in design matrix}

\item{X}{gene expression matrix of size n x p using the
\code{generate_blocks} function}

\item{beta}{true beta coefficient vector}

\item{binary_outcome}{Logical. Should a binary outcome be generated. Default
is \code{FALSE}. See details on how a binary outcome is generated}

\item{truemodule}{numeric vector of the true module membership used in the
\code{s_response_mars} function. Modules 3 and 4 are active in the
response. See \code{s_response_mars} function for details.}

\item{nActive}{number of active genes in the response used in the
\code{s_response_mars}}

\item{cluster_distance}{character representing which matrix from the training
set that you want to use to cluster the genes. Must be one of the following
\itemize{ \item corr, corr0, corr1, tom, tom0, tom1, diffcorr, difftom,
corScor, tomScor, fisherScore }}

\item{n}{total number of subjects}

\item{n0}{total number of subjects with E=0}

\item{include_interaction}{Should an interaction with the environment be
generated as part of the response. Default is FALSE.}

\item{signal_to_noise_ratio}{signal to noise ratio, default is 1}

\item{eclust_distance}{character representing which matrix from the training
set that you want to use to cluster the genes based on the environment. See
\code{cluster_distance} for avaialble options. Should be different from
\code{cluster_distance}. For example, if \code{cluster_distance=corr} and
\code{EclustDistance=fisherScore}. That is, one should be based on
correlations ignoring the environment, and the other should be based on
correlations accounting for the environment. This function will always
return this add on}

\item{cluster_method}{Cluster the data using hierarchical clustering or
prototype clustering. Defaults \code{cluster_method="hclust"}. Other option
is \code{\link[protoclust]{protoclust}}, however this package must be
installed before proceeding with this option}

\item{cut_method}{what method to use to cut the dendrogram. \code{'dynamic'}
refers to \code{dynamicTreeCut} library. \code{'gap'} is Tibshirani's gap
statistic \code{\link[cluster]{clusGap}} using the \code{'Tibs2001SEmax'}
rule. \code{'fixed'} is a fixed number specified by the \code{n_clusters}
argument}

\item{distance_method}{one of "euclidean","maximum","manhattan", "canberra",
"binary","minkowski" to be passed to \code{\link[stats]{dist}} function.}

\item{n_clusters}{Number of clusters specified by the user. Only applicable
when \code{cut_method="fixed"}}

\item{agglomeration_method}{the agglomeration method to be used. This should
be (an unambiguous abbreviation of) one of "ward.D", "ward.D2", "single",
"complete", "average" (= UPGMA), "mcquitty" (= WPGMA), "median" (= WPGMC)
or "centroid" (= UPGMC).}

\item{nPC}{number of principal components. Can be 1 or 2.}

\item{K.max}{the maximum number of clusters to consider, must be at least
two. Only used if \code{cutMethod='gap'}}

\item{B}{integer, number of Monte Carlo (“bootstrap”) samples. Only used if
\code{cutMethod='gap'}}
}
\value{
list of (in the following order) \describe{ \item{beta_truth}{}
  \item{distance}{} \item{DT}{data.table of simulated data from the
  \code{s_response} function} \item{Y}{} \item{X0}{} \item{X1}{}
  \item{X_train}{} \item{X_test}{} \item{Y_train}{} \item{Y_test}{}
  \item{DT_train}{} \item{DT_test}{} \item{S0}{} \item{n_clusters}{}
  \item{clustered_genes_train}{} \item{clustered_genes_test}{}
  \item{clusters}{} \item{tom_train_all}{} \item{tom_train_diff}{}
  \item{tom_train_e1}{} \item{tom_train_e0}{} \item{corr_train_all}{}
  \item{corr_train_diff}{} \item{corr_train_e1}{} \item{corr_train_e0}{}
  \item{mse_null}{} }
}
\description{
create a function that takes as input, the number of genes, the
  true beta vector, the gene expression matrix created from the
  generate_blocks function and returns a list of data matrix, as well as
  correlation matrices, TOM matrices, cluster information, training and test
  data
}
\examples{
library(magrittr)

# simulation parameters
rho = 0.90; p = 500 ;SNR = 1 ; n = 200; n0 = n1 = 100 ; nActive = p*0.10 ; cluster_distance = "tom";
Ecluster_distance = "difftom"; rhoOther = 0.6; betaMean = 2;
alphaMean = 1; betaE = 3; distanceMethod = "euclidean"; clustMethod = "hclust";
cutMethod = "dynamic"; agglomerationMethod = "average"

#in this simulation its blocks 3 and 4 that are important
#leaveOut:  optional specification of modules that should be left out
#of the simulation, that is their genes will be simulated as unrelated
#("grey"). This can be useful when simulating several sets, in some which a module
#is present while in others it is absent.
d0 <- s_modules(n = n0, p = p, rho = 0, exposed = FALSE,
                modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                minCor = 0.01,
                maxCor = 1,
                corPower = 1,
                propNegativeCor = 0.3,
                backgroundNoise = 0.5,
                signed = FALSE,
                leaveOut = 1:4)

d1 <- s_modules(n = n1, p = p, rho = rho, exposed = TRUE,
                modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                minCor = 0.4,
                maxCor = 1,
                corPower = 0.3,
                propNegativeCor = 0.3,
                backgroundNoise = 0.5,
                signed = FALSE)

truemodule1 <- d1$setLabels

X <- rbind(d0$datExpr, d1$datExpr) \%>\%
  magrittr::set_colnames(paste0("Gene", 1:p)) \%>\%
  magrittr::set_rownames(paste0("Subject",1:n))

betaMainEffect <- vector("double", length = p)

# the first nActive/2 in the 3rd block are active
betaMainEffect[which(truemodule1 \%in\% 3)[1:(nActive/2)]] <- runif(
  nActive/2, betaMean - 0.1, betaMean + 0.1)

# the first nActive/2 in the 4th block are active
betaMainEffect[which(truemodule1 \%in\% 4)[1:(nActive/2)]] <- runif(
  nActive/2, betaMean+2 - 0.1, betaMean+2 + 0.1)
beta <- c(betaMainEffect, betaE)

result <- s_generate_data_mars(p = p, X = X,
                               beta = beta,
                               binary_outcome = F,
                               truemodule = truemodule1,
                               nActive = nActive,
                               include_interaction = FALSE,
                               cluster_distance = cluster_distance,
                               n = n, n0 = n0,
                               eclust_distance = Ecluster_distance,
                               signal_to_noise_ratio = SNR,
                               distance_method = distanceMethod,
                               cluster_method = clustMethod,
                               cut_method = cutMethod,
                               agglomeration_method = agglomerationMethod,
                               nPC = 1)
names(result)
}

