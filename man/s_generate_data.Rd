% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulation_functions.R
\name{s_generate_data}
\alias{s_generate_data}
\title{Generate linear response data and test and training sets for simulation study}
\usage{
s_generate_data(p, X, beta, cluster_distance = c("corr", "corr0", "corr1",
  "tom", "tom0", "tom1", "diffcorr", "difftom", "corScor", "tomScor",
  "fisherScore"), n, n0, include_interaction = F, signal_to_noise_ratio = 1,
  eclust_distance = c("fisherScore", "corScor", "diffcorr", "difftom"),
  cluster_method = c("hclust", "protoclust"), cut_method = c("dynamic",
  "gap", "fixed"), distance_method = c("euclidean", "maximum", "manhattan",
  "canberra", "binary", "minkowski"), n_clusters,
  agglomeration_method = c("complete", "average", "ward.D2", "single",
  "ward.D", "mcquitty", "median", "centroid"), nPC = 1, K.max = 10,
  B = 10)
}
\arguments{
\item{p}{number of genes in design matrix}

\item{X}{gene expression matrix of size n x p using the
\code{generate_blocks} function}

\item{beta}{true beta coefficient vector}

\item{cluster_distance}{character representing which matrix from the training
set that you want to use to cluster the genes. Must be one of the following
\itemize{ \item corr, corr0, corr1, tom, tom0, tom1, diffcorr, difftom,
corScor, tomScor, fisherScore }}

\item{n}{total number of subjects}

\item{n0}{total number of subjects with E=0}

\item{include_interaction}{Should an interaction with the environment be
generated as part of the response. Default is FALSE.}

\item{signal_to_noise_ratio}{signal to noise ratio, default is 1}

\item{eclust_distance}{character representing which matrix from the training
set that you want to use to cluster the genes based on the environment. See
\code{cluster_distance} for avaialble options. Should be different from
\code{cluster_distance}. For example, if \code{cluster_distance=corr} and
\code{EclustDistance=fisherScore}. That is, one should be based on
correlations ignoring the environment, and the other should be based on
correlations accounting for the environment. This function will always
return this add on}

\item{cluster_method}{Cluster the data using hierarchical clustering or
prototype clustering. Defaults \code{clustMethod="hclust"}. Other option is
\code{\link[protoclust]{protoclust}}, however this package must be
installed before proceeding with this option}

\item{cut_method}{what method to use to cut the dendrogram. \code{'dynamic'}
refers to \code{\link[dynamicTreeCut]{}} library. \code{'gap'} is
Tibshirani's gap statistic \code{\link[cluster]{clusGap}} using the
\code{'Tibs2001SEmax'} rule. \code{'fixed'} is a fixed number specified by
the \code{n_clusters} argument}

\item{distance_method}{one of "euclidean","maximum","manhattan", "canberra",
"binary","minkowski" to be passed to \code{\link[stats]{dist}} function.}

\item{agglomeration_method}{the agglomeration method to be used. This should
be (an unambiguous abbreviation of) one of "ward.D", "ward.D2", "single",
"complete", "average" (= UPGMA), "mcquitty" (= WPGMA), "median" (= WPGMC)
or "centroid" (= UPGMC).}

\item{nPC}{number of principal components to extract from each cluster.
Default is 1. Only 1 or 2 is allowed.}

\item{K.max}{the maximum number of clusters to consider, must be at least
two. Only used if \code{cutMethod='gap'}}

\item{B}{integer, number of Monte Carlo (“bootstrap”) samples. Only used if
\code{cutMethod='gap'}}
}
\value{
list of (in the following order) \describe{ \item{beta_truth}{}
  \item{distance}{} \item{DT}{data.table of simulated data from the
  \code{s_response} function} \item{Y}{} \item{X0}{} \item{X1}{}
  \item{X_train}{} \item{X_test}{} \item{Y_train}{} \item{Y_test}{}
  \item{DT_train}{} \item{DT_test}{} \item{S0}{} \item{n_clusters}{}
  \item{clustered_genes_train}{} \item{clustered_genes_test}{}
  \item{clusters}{} \item{tom_train_all}{} \item{tom_train_diff}{}
  \item{tom_train_e1}{} \item{tom_train_e0}{} \item{corr_train_all}{}
  \item{corr_train_diff}{} \item{corr_train_e1}{} \item{corr_train_e0}{}
  \item{mse_null}{} }
}
\description{
create a function that takes as input, the number of genes, the
  true beta vector, the gene expression matrix created from the
  generate_blocks function and returns a list of data matrix, as well as
  correlation matrices, TOM matrices, cluster information, training and test
  data
}
\note{
this function calls the \code{s_response} to generate phenotype as a
  function of the gene expression data. This function also returns other
  information derived from the simulated data including the test and training
  sets, the correlation and TOM matrices and the clusters.

the PCs and averages need to be calculated in the fitting functions,
  because these will change based on the CV fold
}
\examples{
\dontrun{
p = 1000
n=200;n0=100
beta_genes <- c(runif(50,0.9,1.1),
                runif(50, -1.1,-0.9),
                rep(0,900))
# gene expression matrix used in s_response function
X <- mapply(generate_blocks,
            rho_E0 = c(-0.70, runif(8, 0.01,0.05), 0.70),
            rho_E1 = c(0.70, runif(8, 0.01, 0.05), 0.70),
            MoreArgs = list(block_size = 100, n = n, n0 = n0), SIMPLIFY = F) \%>\%
  do.call(cbind, . ) \%>\%
  magrittr::set_colnames(paste0("Gene", 1:1000)) \%>\%
  magrittr::set_rownames(paste0("Subject",1:200))

cluster_distance <- "corr"
generate_data(p = p, n = n, n0 = n0, X = X, beta_genes = beta_genes, cluster_distance = "corr")
}
}

