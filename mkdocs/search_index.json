{
    "docs": [
        {
            "location": "/",
            "text": "eclust\n R Package\n\u00b6\n\n\n\n\n\n\nThis package clusters gene expression or DNA methylation data that is sensitive to environmental exposures. It is the companion package to the paper\n\n\n\n\n\n\nBhatnagar, SR., Yang, Y., Blanchette, M., Bouchard, L., Khundrakpam, B., Evans, A., Greenwood, CMT. (2017+). An analytic approach for interpretable predictive models in high dimensional data, in the presence of interactions with exposures. \nPreprint",
            "title": "Home"
        },
        {
            "location": "/#eclust-r-package",
            "text": "This package clusters gene expression or DNA methylation data that is sensitive to environmental exposures. It is the companion package to the paper    Bhatnagar, SR., Yang, Y., Blanchette, M., Bouchard, L., Khundrakpam, B., Evans, A., Greenwood, CMT. (2017+). An analytic approach for interpretable predictive models in high dimensional data, in the presence of interactions with exposures.  Preprint",
            "title": "eclust R Package"
        },
        {
            "location": "/installation/",
            "text": "Installation\n\u00b6\n\n\nYou can install \neclust\n from \nCRAN\n:\n\n\ninstall.packages\n(\n\"eclust\"\n)\n\n\n\n\n\n\nAlternatively, you can install the development version of \neclust\n from \nGitHub\n with:\n\n\ninstall.packages\n(\n\"pacman\"\n)\n\npacman\n::\np_load_gh\n(\n\"sahirbhatnagar/eclust\"\n)",
            "title": "Installation"
        },
        {
            "location": "/installation/#installation",
            "text": "You can install  eclust  from  CRAN :  install.packages ( \"eclust\" )   Alternatively, you can install the development version of  eclust  from  GitHub  with:  install.packages ( \"pacman\" ) \npacman :: p_load_gh ( \"sahirbhatnagar/eclust\" )",
            "title": "Installation"
        },
        {
            "location": "/data/",
            "text": "Data\n\u00b6\n\n\nThere are two datasets included in this package that can be loaded into your \nR\n session via \ndata(tcgaov)\n and \ndata(simdata)\n:\n\n\n\n\ntcgaov\n: A dataset containing a subset of the TCGA mRNA Ovarian serous cystadenocarcinoma data generated using Affymetrix HTHGU133a arrays. 511 samples (rows) and 881 genes (columns).\n\n\nsimdata\n: A dataset containing simulated data for example use of the \neclust\n package functions. A matrix with 200 rows 1000 genes, a continuous response Y and a binary environment vector E.",
            "title": "Data"
        },
        {
            "location": "/data/#data",
            "text": "There are two datasets included in this package that can be loaded into your  R  session via  data(tcgaov)  and  data(simdata) :   tcgaov : A dataset containing a subset of the TCGA mRNA Ovarian serous cystadenocarcinoma data generated using Affymetrix HTHGU133a arrays. 511 samples (rows) and 881 genes (columns).  simdata : A dataset containing simulated data for example use of the  eclust  package functions. A matrix with 200 rows 1000 genes, a continuous response Y and a binary environment vector E.",
            "title": "Data"
        },
        {
            "location": "/overview/",
            "text": "Overview of Functions\n\u00b6\n\n\nThis package has three sets of functions starting with either \nr_\n, \ns_\n or \nu_\n\n\n\n\nr_\n (\nreal data functions\n): related to analysis of real data. Most users will apply this set of functions to their data.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction.name\n\n\n\n\n\n\n\n\n\n\nr_cluster_data\n\n\n\n\n\n\nr_prepare_data\n\n\n\n\n\n\n\n\n\n\n\ns_\n (\nsimulation functions\n): related to the simulations conducted in the \npaper\n. There are functions to simulate data, run the analyses on these data, and output performance metrics.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction.name\n\n\n\n\n\n\n\n\n\n\ns_generate_data\n\n\n\n\n\n\ns_generate_data_mars\n\n\n\n\n\n\ns_mars_clust\n\n\n\n\n\n\ns_mars_separate\n\n\n\n\n\n\ns_modules\n\n\n\n\n\n\ns_pen_clust\n\n\n\n\n\n\ns_pen_separate\n\n\n\n\n\n\ns_response\n\n\n\n\n\n\ns_response_mars\n\n\n\n\n\n\n\n\n\n\n\nu_\n (\nutility functions\n): functions that are used by both simulation and real data analysis functions. Not really meant to be called by the user.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction.name\n\n\n\n\n\n\n\n\n\n\nu_cluster_similarity\n\n\n\n\n\n\nu_extract_selected_earth\n\n\n\n\n\n\nu_extract_summary\n\n\n\n\n\n\nu_fisherZ",
            "title": "Package Functions"
        },
        {
            "location": "/overview/#overview-of-functions",
            "text": "This package has three sets of functions starting with either  r_ ,  s_  or  u_   r_  ( real data functions ): related to analysis of real data. Most users will apply this set of functions to their data.         function.name      r_cluster_data    r_prepare_data      s_  ( simulation functions ): related to the simulations conducted in the  paper . There are functions to simulate data, run the analyses on these data, and output performance metrics.         function.name      s_generate_data    s_generate_data_mars    s_mars_clust    s_mars_separate    s_modules    s_pen_clust    s_pen_separate    s_response    s_response_mars      u_  ( utility functions ): functions that are used by both simulation and real data analysis functions. Not really meant to be called by the user.         function.name      u_cluster_similarity    u_extract_selected_earth    u_extract_summary    u_fisherZ",
            "title": "Overview of Functions"
        },
        {
            "location": "/rda/",
            "text": "Real data analysis functions (\nr_\n)\n\u00b6\n\n\nWe will use the \ndata(tcgaov)\n dataset included in this package, which contains a subset of the TCGA mRNA Ovarian serous cystadenocarcinoma data generated using Affymetrix HTHGU133a arrays. See \n?tcgaov\n for details about the data.\n\n\nIn the example below we use the \nr_cluster_data\n to create the environment based clusters, and their summaries. We then use the \nr_prepare_data\n function to get it into proper form for regression routines such as \nearth::earth\n, \nglmnet::cv.glmnet\n, and \nncvreg::ncvreg\n.\n\n\nExtract the relevant data\n\u00b6\n\n\n# load the data\n\ndata\n(\n\"tcgaov\"\n)\n\ntcgaov\n[\n1\n:\n5\n,\n1\n:\n6\n,\n with \n=\n \nFALSE\n]\n\n\n\n\n\n\n##              rn subtype E status   OS    ABCA8\n## 1: TCGA-04-1331       4 1      1 1336 3.684824\n## 2: TCGA-04-1332       1 0      1 1247 7.892982\n## 3: TCGA-04-1335       3 1      1   55 5.193188\n## 4: TCGA-04-1336       3 1      0 1495 3.055437\n## 5: TCGA-04-1337       1 0      1   61 3.149427\n\n\n\n\n\n# use log survival as the response\n\nY \n<-\n \nlog\n(\ntcgaov\n[[\n\"OS\"\n]])\n\n\n\n# specify the environment variable\n\nE \n<-\n tcgaov\n[[\n\"E\"\n]]\n\n\n\n# specify the matrix of genes only\n\ngenes \n<-\n \nas.matrix\n(\ntcgaov\n[,\n-\nc\n(\n\"OS\"\n,\n\"rn\"\n,\n\"subtype\"\n,\n\"E\"\n,\n\"status\"\n),\nwith \n=\n \nFALSE\n])\n\n\n\n# for this example the training set will be all subjects.\n\n\n# change `p` argument to create a train and test set.\n\ntrainIndex \n<-\n \ndrop\n(\ncaret\n::\ncreateDataPartition\n(\nY\n,\n p \n=\n \n1\n,\n \nlist\n \n=\n \nFALSE\n,\n times \n=\n \n1\n))\n\ntestIndex \n<-\n trainIndex\n\n\n\n\n\nCluster the data and calculate cluster representations\n\u00b6\n\n\nWe cluster the genes using the correlation matrix (specified by \ncluster_distance = \"corr\"\n) and the difference of the exposure dependent correlation matrices (specified by \neclust_distance = \"diffcorr\"\n)\n\n\ncluster_res \n<-\n r_cluster_data\n(\ndata \n=\n genes\n,\n\n                              response \n=\n Y\n,\n\n                              exposure \n=\n E\n,\n\n                              train_index \n=\n trainIndex\n,\n\n                              test_index \n=\n testIndex\n,\n\n                              cluster_distance \n=\n \n\"corr\"\n,\n\n                              eclust_distance \n=\n \n\"diffcorr\"\n,\n\n                              measure_distance \n=\n \n\"euclidean\"\n,\n\n                              clustMethod \n=\n \n\"hclust\"\n,\n\n                              cutMethod \n=\n \n\"dynamic\"\n,\n\n                              method \n=\n \n\"average\"\n,\n\n                              nPC \n=\n \n1\n,\n\n                              minimum_cluster_size \n=\n \n30\n)\n\n\n\n\n\n\n##\n\n##  ..cutHeight not given, setting it to 10.9  ===>  99% of the (truncated) height range in dendro.\n##  ..done.\n\n## Calculating number of environment clusters based on diffcorr\n\n##  ..cutHeight not given, setting it to 0.923  ===>  99% of the (truncated) height range in dendro.\n##  ..done.\n\n## There are 7 clusters derived from the corr similarity matrix\n\n## There are 4 clusters derived from the diffcorr environment similarity matrix\n\n## There are a total of 11 clusters derived from the corr\n##                   similarity matrix and the diffcorr environment similarity matrix\n\n\n\n\n\n# the number of clusters determined by the similarity matrices specified\n\n\n# in the cluster_distance and eclust_distance arguments. This will always be larger\n\n\n# than cluster_res$clustersAll$nclusters which is based on the similarity matrix\n\n\n# specified in the cluster_distance argument\n\ncluster_res\n$\nclustersAddon\n$\nnclusters\n\n\n\n\n\n## [1] 11\n\n\n\n\n\n# the number of clusters determined by the similarity matrices specified\n\n\n# in the cluster_distance argument only\n\ncluster_res\n$\nclustersAll\n$\nnclusters\n\n\n\n\n\n## [1] 7\n\n\n\n\n\n# what's in the cluster_res object\n\n\nnames\n(\ncluster_res\n)\n\n\n\n\n\n\n## [1] \"clustersAddon\"            \"clustersAll\"             \n## [3] \"etrain\"                   \"clustersAddonMembership\" \n## [5] \"clustersAllMembership\"    \"clustersEclustMembership\"\n\n\n\n\n\nPrepare data for input in any regression routine\n\u00b6\n\n\nNow we use the \nr_prepare_data\n function, where we are using the average expression from each cluster as feaand their interaction with E as features in the regression model:\n\n\n# prepare data for use with earth function\n\navg_eclust_interaction \n<-\n r_prepare_data\n(\n\n  data \n=\n \ncbind\n(\ncluster_res\n$\nclustersAddon\n$\naverageExpr\n,\n \n               Y \n=\n Y\n[\ntrainIndex\n],\n\n               E \n=\n E\n[\ntrainIndex\n]),\n\n  response \n=\n \n\"Y\"\n,\n exposure \n=\n \n\"E\"\n)\n\n\n\nhead\n(\navg_eclust_interaction\n[[\n\"X\"\n]])\n\n\n\n\n\n\n##       avg1     avg2     avg3     avg4     avg5     avg6     avg7     avg8\n## 1 5.567323 4.603389 5.645931 5.463546 6.330674 5.017668 5.723670 4.537860\n## 2 6.416015 5.135543 5.915361 5.412958 6.539799 5.514176 6.330553 4.949290\n## 3 4.751661 4.428877 6.064181 4.553495 5.647454 5.434861 4.854128 4.923794\n## 4 4.488082 5.360132 6.184347 4.440893 7.747494 5.475239 5.509369 4.919032\n## 5 6.661257 5.316210 5.873579 4.951189 5.769990 5.254726 6.868405 4.618736\n## 6 6.206893 5.783308 6.017647 4.862209 6.001902 5.370070 6.680607 4.444538\n##       avg9    avg10    avg11 E   avg1:E   avg2:E   avg3:E   avg4:E\n## 1 5.504560 5.769372 4.604983 1 5.567323 4.603389 5.645931 5.463546\n## 2 6.195038 6.119165 4.787305 0 0.000000 0.000000 0.000000 0.000000\n## 3 4.829277 5.675971 4.227867 1 4.751661 4.428877 6.064181 4.553495\n## 4 4.855203 6.117120 4.754397 1 4.488082 5.360132 6.184347 4.440893\n## 5 6.282899 5.814544 5.048062 0 0.000000 0.000000 0.000000 0.000000\n## 6 6.000493 6.044401 5.190256 0 0.000000 0.000000 0.000000 0.000000\n##     avg5:E   avg6:E   avg7:E   avg8:E   avg9:E  avg10:E  avg11:E\n## 1 6.330674 5.017668 5.723670 4.537860 5.504560 5.769372 4.604983\n## 2 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000\n## 3 5.647454 5.434861 4.854128 4.923794 4.829277 5.675971 4.227867\n## 4 7.747494 5.475239 5.509369 4.919032 4.855203 6.117120 4.754397\n## 5 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000\n## 6 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000\n\n\n\n\n\nFit a regression model\n\u00b6\n\n\nAt this stage, you can decide which regression model to use. Here we choose the MARS model from the \nearth\n package, but you may choose regression models from any number of packages (e.g. see the \nextensive list of models\n of models available in the \ncaret\n package).\n\n\nfit_earth \n<-\n earth\n::\nearth\n(\nx \n=\n avg_eclust_interaction\n[[\n\"X\"\n]],\n \n                          y \n=\n avg_eclust_interaction\n[[\n\"Y\"\n]],\n \n                          pmethod \n=\n \n\"backward\"\n,\n \n                          keepxy \n=\n \nTRUE\n,\n \n                          degree \n=\n \n2\n,\n \n                          trace \n=\n \n1\n,\n \n                          nk \n=\n \n1000\n)\n\n\n\n\n\n\n## x[511,23] with colnames avg1 avg2 avg3 avg4 avg5 avg6 avg7 avg8 avg9 avg10 avg11 ...\n## y[511,1] with colname avg_eclust_interaction[[\"Y\"]]\n## Forward pass term 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, \n##      30, 32, 34, 36, 38\n## RSq changed by less than 0.001 at 37 terms, 35 terms used (DeltaRSq 0)\n## After forward pass GRSq -0.176 RSq 0.193\n## Prune method \"backward\" penalty 3 nprune null: selected 6 of 35 terms, and 4 of 23 preds\n## After pruning pass GRSq 0.01 RSq 0.0579\n\n\n\n\n\ncoef\n(\nfit_earth\n)\n\n\n\n\n\n\n##                         (Intercept) h(avg9-5.58701) * h(6.54361-avg5:E) \n##                            6.718508                            1.070107 \n##   h(avg1-5.99657) * h(avg7-6.84195)   h(avg1-5.99657) * h(avg7-6.70675) \n##                           67.850654                          -39.786576 \n##   h(avg1-5.99657) * h(avg7-6.98039)                     h(avg9-5.50456) \n##                          -28.720223                           -5.293762\n\n\n\n\n\nYou can also install the \nplotmo\n package to visualise the relationships between the hinge functions and the response using \nplotmo::plotmo(fit_earth)\n.\n\n\nDetermine the features that have been selected\n\u00b6\n\n\nThe \nu_extract_selected_earth\n is a utility function in this package to extract the selected predictors from the MARS model:\n\n\nu_extract_selected_earth\n(\nfit_earth\n)\n\n\n\n\n\n\n## [1] \"avg1\"   \"avg7\"   \"avg9\"   \"avg5:E\"\n\n\n\n\n\nWe that genes in clusters 1, 7 and 9 were selected. We also see that the interaction between the genes in cluster 5 and the environment was selected and has the highest variable importance. We can see the genes involved using the \ncluster_res$clustersAddonMembership\n object:\n\n\n# Genes in cluster 5\n\ncluster_res\n$\nclustersAddonMembership\n[\ncluster \n%in%\n \n5\n]\n\n\n\n\n\n\n##         gene cluster module\n##  1: APOBEC3G       5  green\n##  2:    APOL6       5  green\n##  3:   CXCL10       5  green\n##  4:   CXCL11       5  green\n##  5:     GBP1       5  green\n##  6:     HCP5       5  green\n##  7:     IL15       5  green\n##  8:    PSMB9       5  green\n##  9:  RARRES3       5  green\n## 10:     TAP1       5  green\n## 11:     BST2       5  green\n## 12:   BTN3A2       5  green\n## 13:       C2       5  green\n## 14:     CBR3       5  green\n## 15: CCDC109B       5  green\n## 16:     HPSE       5  green\n## 17:  HTATIP2       5  green\n## 18:    IFI16       5  green\n## 19:    IFI27       5  green\n## 20:    IFI35       5  green\n## 21:    IFI44       5  green\n## 22:   IFI44L       5  green\n## 23:    IFIH1       5  green\n## 24:    IFIT1       5  green\n## 25:    IFIT2       5  green\n## 26:    IFIT3       5  green\n## 27:   IFITM1       5  green\n## 28:   IL15RA       5  green\n## 29:     IRF1       5  green\n## 30:     IRF7       5  green\n## 31:    ISG15       5  green\n## 32:    ISG20       5  green\n## 33:    LAMP3       5  green\n## 34:     LAP3       5  green\n## 35:   LGALS9       5  green\n## 36:      MX1       5  green\n## 37:     OAS1       5  green\n## 38:     OAS2       5  green\n## 39:     OAS3       5  green\n## 40:   PLSCR1       5  green\n## 41:   PSMB10       5  green\n## 42:    PSMB8       5  green\n## 43:    PSME2       5  green\n## 44:    RSAD2       5  green\n## 45:     RTP4       5  green\n## 46:    SAMD9       5  green\n## 47:  SLC15A3       5  green\n## 48:    SP100       5  green\n## 49:     TAP2       5  green\n## 50:    TAPBP       5  green\n## 51:     TLR3       5  green\n## 52:  TMEM140       5  green\n## 53:  TNFAIP8       5  green\n## 54:  TNFSF10       5  green\n## 55:   TRIM14       5  green\n## 56:   UBE2L6       5  green\n## 57:     XAF1       5  green\n##         gene cluster module\n\n\n\n\n\n# variable importance\n\nearth\n::\nevimp\n(\nfit_earth\n)\n\n\n\n\n\n\n##              nsubsets   gcv    rss\n## avg5:E              4  84.7  100.0\n## avg11-unused        3 -49.6   73.9\n## avg1                2 100.0>  81.8>\n## avg7                2 100.0   81.8\n## avg9                2 100.0   81.8",
            "title": "Real Data Analysis"
        },
        {
            "location": "/rda/#real-data-analysis-functions-r_",
            "text": "We will use the  data(tcgaov)  dataset included in this package, which contains a subset of the TCGA mRNA Ovarian serous cystadenocarcinoma data generated using Affymetrix HTHGU133a arrays. See  ?tcgaov  for details about the data.  In the example below we use the  r_cluster_data  to create the environment based clusters, and their summaries. We then use the  r_prepare_data  function to get it into proper form for regression routines such as  earth::earth ,  glmnet::cv.glmnet , and  ncvreg::ncvreg .",
            "title": "Real data analysis functions (r_)"
        },
        {
            "location": "/rda/#extract-the-relevant-data",
            "text": "# load the data \ndata ( \"tcgaov\" ) \ntcgaov [ 1 : 5 , 1 : 6 ,  with  =   FALSE ]   ##              rn subtype E status   OS    ABCA8\n## 1: TCGA-04-1331       4 1      1 1336 3.684824\n## 2: TCGA-04-1332       1 0      1 1247 7.892982\n## 3: TCGA-04-1335       3 1      1   55 5.193188\n## 4: TCGA-04-1336       3 1      0 1495 3.055437\n## 5: TCGA-04-1337       1 0      1   61 3.149427  # use log survival as the response \nY  <-   log ( tcgaov [[ \"OS\" ]])  # specify the environment variable \nE  <-  tcgaov [[ \"E\" ]]  # specify the matrix of genes only \ngenes  <-   as.matrix ( tcgaov [, - c ( \"OS\" , \"rn\" , \"subtype\" , \"E\" , \"status\" ), with  =   FALSE ])  # for this example the training set will be all subjects.  # change `p` argument to create a train and test set. \ntrainIndex  <-   drop ( caret :: createDataPartition ( Y ,  p  =   1 ,   list   =   FALSE ,  times  =   1 )) \ntestIndex  <-  trainIndex",
            "title": "Extract the relevant data"
        },
        {
            "location": "/rda/#cluster-the-data-and-calculate-cluster-representations",
            "text": "We cluster the genes using the correlation matrix (specified by  cluster_distance = \"corr\" ) and the difference of the exposure dependent correlation matrices (specified by  eclust_distance = \"diffcorr\" )  cluster_res  <-  r_cluster_data ( data  =  genes , \n                              response  =  Y , \n                              exposure  =  E , \n                              train_index  =  trainIndex , \n                              test_index  =  testIndex , \n                              cluster_distance  =   \"corr\" , \n                              eclust_distance  =   \"diffcorr\" , \n                              measure_distance  =   \"euclidean\" , \n                              clustMethod  =   \"hclust\" , \n                              cutMethod  =   \"dynamic\" , \n                              method  =   \"average\" , \n                              nPC  =   1 , \n                              minimum_cluster_size  =   30 )   ##\n\n##  ..cutHeight not given, setting it to 10.9  ===>  99% of the (truncated) height range in dendro.\n##  ..done.\n\n## Calculating number of environment clusters based on diffcorr\n\n##  ..cutHeight not given, setting it to 0.923  ===>  99% of the (truncated) height range in dendro.\n##  ..done.\n\n## There are 7 clusters derived from the corr similarity matrix\n\n## There are 4 clusters derived from the diffcorr environment similarity matrix\n\n## There are a total of 11 clusters derived from the corr\n##                   similarity matrix and the diffcorr environment similarity matrix  # the number of clusters determined by the similarity matrices specified  # in the cluster_distance and eclust_distance arguments. This will always be larger  # than cluster_res$clustersAll$nclusters which is based on the similarity matrix  # specified in the cluster_distance argument \ncluster_res $ clustersAddon $ nclusters  ## [1] 11  # the number of clusters determined by the similarity matrices specified  # in the cluster_distance argument only \ncluster_res $ clustersAll $ nclusters  ## [1] 7  # what's in the cluster_res object  names ( cluster_res )   ## [1] \"clustersAddon\"            \"clustersAll\"             \n## [3] \"etrain\"                   \"clustersAddonMembership\" \n## [5] \"clustersAllMembership\"    \"clustersEclustMembership\"",
            "title": "Cluster the data and calculate cluster representations"
        },
        {
            "location": "/rda/#prepare-data-for-input-in-any-regression-routine",
            "text": "Now we use the  r_prepare_data  function, where we are using the average expression from each cluster as feaand their interaction with E as features in the regression model:  # prepare data for use with earth function \navg_eclust_interaction  <-  r_prepare_data ( \n  data  =   cbind ( cluster_res $ clustersAddon $ averageExpr ,  \n               Y  =  Y [ trainIndex ], \n               E  =  E [ trainIndex ]), \n  response  =   \"Y\" ,  exposure  =   \"E\" )  head ( avg_eclust_interaction [[ \"X\" ]])   ##       avg1     avg2     avg3     avg4     avg5     avg6     avg7     avg8\n## 1 5.567323 4.603389 5.645931 5.463546 6.330674 5.017668 5.723670 4.537860\n## 2 6.416015 5.135543 5.915361 5.412958 6.539799 5.514176 6.330553 4.949290\n## 3 4.751661 4.428877 6.064181 4.553495 5.647454 5.434861 4.854128 4.923794\n## 4 4.488082 5.360132 6.184347 4.440893 7.747494 5.475239 5.509369 4.919032\n## 5 6.661257 5.316210 5.873579 4.951189 5.769990 5.254726 6.868405 4.618736\n## 6 6.206893 5.783308 6.017647 4.862209 6.001902 5.370070 6.680607 4.444538\n##       avg9    avg10    avg11 E   avg1:E   avg2:E   avg3:E   avg4:E\n## 1 5.504560 5.769372 4.604983 1 5.567323 4.603389 5.645931 5.463546\n## 2 6.195038 6.119165 4.787305 0 0.000000 0.000000 0.000000 0.000000\n## 3 4.829277 5.675971 4.227867 1 4.751661 4.428877 6.064181 4.553495\n## 4 4.855203 6.117120 4.754397 1 4.488082 5.360132 6.184347 4.440893\n## 5 6.282899 5.814544 5.048062 0 0.000000 0.000000 0.000000 0.000000\n## 6 6.000493 6.044401 5.190256 0 0.000000 0.000000 0.000000 0.000000\n##     avg5:E   avg6:E   avg7:E   avg8:E   avg9:E  avg10:E  avg11:E\n## 1 6.330674 5.017668 5.723670 4.537860 5.504560 5.769372 4.604983\n## 2 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000\n## 3 5.647454 5.434861 4.854128 4.923794 4.829277 5.675971 4.227867\n## 4 7.747494 5.475239 5.509369 4.919032 4.855203 6.117120 4.754397\n## 5 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000\n## 6 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000",
            "title": "Prepare data for input in any regression routine"
        },
        {
            "location": "/rda/#fit-a-regression-model",
            "text": "At this stage, you can decide which regression model to use. Here we choose the MARS model from the  earth  package, but you may choose regression models from any number of packages (e.g. see the  extensive list of models  of models available in the  caret  package).  fit_earth  <-  earth :: earth ( x  =  avg_eclust_interaction [[ \"X\" ]],  \n                          y  =  avg_eclust_interaction [[ \"Y\" ]],  \n                          pmethod  =   \"backward\" ,  \n                          keepxy  =   TRUE ,  \n                          degree  =   2 ,  \n                          trace  =   1 ,  \n                          nk  =   1000 )   ## x[511,23] with colnames avg1 avg2 avg3 avg4 avg5 avg6 avg7 avg8 avg9 avg10 avg11 ...\n## y[511,1] with colname avg_eclust_interaction[[\"Y\"]]\n## Forward pass term 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, \n##      30, 32, 34, 36, 38\n## RSq changed by less than 0.001 at 37 terms, 35 terms used (DeltaRSq 0)\n## After forward pass GRSq -0.176 RSq 0.193\n## Prune method \"backward\" penalty 3 nprune null: selected 6 of 35 terms, and 4 of 23 preds\n## After pruning pass GRSq 0.01 RSq 0.0579  coef ( fit_earth )   ##                         (Intercept) h(avg9-5.58701) * h(6.54361-avg5:E) \n##                            6.718508                            1.070107 \n##   h(avg1-5.99657) * h(avg7-6.84195)   h(avg1-5.99657) * h(avg7-6.70675) \n##                           67.850654                          -39.786576 \n##   h(avg1-5.99657) * h(avg7-6.98039)                     h(avg9-5.50456) \n##                          -28.720223                           -5.293762  You can also install the  plotmo  package to visualise the relationships between the hinge functions and the response using  plotmo::plotmo(fit_earth) .",
            "title": "Fit a regression model"
        },
        {
            "location": "/rda/#determine-the-features-that-have-been-selected",
            "text": "The  u_extract_selected_earth  is a utility function in this package to extract the selected predictors from the MARS model:  u_extract_selected_earth ( fit_earth )   ## [1] \"avg1\"   \"avg7\"   \"avg9\"   \"avg5:E\"  We that genes in clusters 1, 7 and 9 were selected. We also see that the interaction between the genes in cluster 5 and the environment was selected and has the highest variable importance. We can see the genes involved using the  cluster_res$clustersAddonMembership  object:  # Genes in cluster 5 \ncluster_res $ clustersAddonMembership [ cluster  %in%   5 ]   ##         gene cluster module\n##  1: APOBEC3G       5  green\n##  2:    APOL6       5  green\n##  3:   CXCL10       5  green\n##  4:   CXCL11       5  green\n##  5:     GBP1       5  green\n##  6:     HCP5       5  green\n##  7:     IL15       5  green\n##  8:    PSMB9       5  green\n##  9:  RARRES3       5  green\n## 10:     TAP1       5  green\n## 11:     BST2       5  green\n## 12:   BTN3A2       5  green\n## 13:       C2       5  green\n## 14:     CBR3       5  green\n## 15: CCDC109B       5  green\n## 16:     HPSE       5  green\n## 17:  HTATIP2       5  green\n## 18:    IFI16       5  green\n## 19:    IFI27       5  green\n## 20:    IFI35       5  green\n## 21:    IFI44       5  green\n## 22:   IFI44L       5  green\n## 23:    IFIH1       5  green\n## 24:    IFIT1       5  green\n## 25:    IFIT2       5  green\n## 26:    IFIT3       5  green\n## 27:   IFITM1       5  green\n## 28:   IL15RA       5  green\n## 29:     IRF1       5  green\n## 30:     IRF7       5  green\n## 31:    ISG15       5  green\n## 32:    ISG20       5  green\n## 33:    LAMP3       5  green\n## 34:     LAP3       5  green\n## 35:   LGALS9       5  green\n## 36:      MX1       5  green\n## 37:     OAS1       5  green\n## 38:     OAS2       5  green\n## 39:     OAS3       5  green\n## 40:   PLSCR1       5  green\n## 41:   PSMB10       5  green\n## 42:    PSMB8       5  green\n## 43:    PSME2       5  green\n## 44:    RSAD2       5  green\n## 45:     RTP4       5  green\n## 46:    SAMD9       5  green\n## 47:  SLC15A3       5  green\n## 48:    SP100       5  green\n## 49:     TAP2       5  green\n## 50:    TAPBP       5  green\n## 51:     TLR3       5  green\n## 52:  TMEM140       5  green\n## 53:  TNFAIP8       5  green\n## 54:  TNFSF10       5  green\n## 55:   TRIM14       5  green\n## 56:   UBE2L6       5  green\n## 57:     XAF1       5  green\n##         gene cluster module  # variable importance \nearth :: evimp ( fit_earth )   ##              nsubsets   gcv    rss\n## avg5:E              4  84.7  100.0\n## avg11-unused        3 -49.6   73.9\n## avg1                2 100.0>  81.8>\n## avg7                2 100.0   81.8\n## avg9                2 100.0   81.8",
            "title": "Determine the features that have been selected"
        },
        {
            "location": "/simulation/",
            "text": "Simulation functions (\ns_\n)\n\u00b6\n\n\nThe \ns_\n functions were used to conduct the simulation studies in the\n\nBhatnagar et.al (2017+)\n. The \ns_modules\n, \ns_generate_data\n and\n\ns_generate_data_mars\n are the main functions to generate the simulated\ndata.\n\n\nIn the paper we designed 6 simulation scenarios that are constructed to\nillustrate different kinds of relationships between the variables and\nthe response. For all scenarios, we have created high dimensional data\nsets with \\( p \\) predictors, and sample sizes of \\( n \\). We also\nassume that we have two data sets for each simulation - a training data\nset where the parameters are estimated, and a testing data set where\nprediction performance is evaluated, each of equal size \\( n_{train} =\nn_{test} \\). The number of subjects who were exposed (\\( n_{E=1}=100\n\\)) and unexposed (\\( n_{E=0}=100 \\)) and the number of truly\nassociated parameters (\\( 0.10 * p \\)) remain fixed across the 6\nsimulation scenarios.\n\n\nLet\n\n\n\n\n Y = Y^* + k \\cdot \\varepsilon \n\n\n\n\nwhere \\( Y ^ * \\) is the linear predictor, the error term \\(\n\\varepsilon \\) is generated from a standard normal distribution, and\n\\( k \\) is chosen such that the signal-to-noise ratio\n\n SNR = \\left(Var(Y^*) \\over Var(\\varepsilon)\\right) \n is 0.2, 1 and 2\n(e.g. the variance of the response variable \\( Y \\) due to \\(\n\\varepsilon \\) is \\( 1/SNR \\) of the variance of \\( Y \\) due to \\(\nY^* \\)).\n\n\nThe Design Matrix\n\u00b6\n\n\nWe generate covariate data in 5 blocks using the \ns_modules\n function\nwhich is a wrapper of the \nsimulateDatExpr\n function from the \nWGCNA\n\npackage in \nR\n (version 1.51). This generates data from a latent vector:\nfirst a seed vector is simulated, then covariates are generated with\nvarying degree of correlation with the seed vector in a given block.\n\n\nFor the unexposed observations (\\( E=0 \\)), only the predictors in the\nyellow block were simulated with correlation, while all other covariates\nwere independent within and between blocks. For the exposed observations\n(\\( E=1 \\)), all 5 blocks contained predictors that are correlated.\n\n\nFor simplicity, we will refer to the simulated data as gene expression\ndata, with each column of the design matrix being a gene. First we\ngenerate gene expression data for \\( p=1000 \\) genes, independently\nfor the 100 unexposed (\nd0\n) and 100 exposed (\nd1\n) subjects using the\n\ns_modules\n function. The exposed subjects are meant to have correlated\ngenes while the unexposed subject don't. The \nmodProportions\n argument\nis a numeric vector with length equal the number of modules you want to\ngenerate plus one, containing fractions of the total number of genes to\nbe put into each of the modules and into the \"grey module\", which means\ngenes not related to any of the modules. In the following examples we\ngenerate 5 modules of equal size (15% of \\( p \\) each module) plus 1\n\"grey\" module (25% of \\( p \\))\n\n\npacman\n::\np_load\n(\neclust\n)\n\nd0 \n<-\n s_modules\n(\nn \n=\n \n100\n,\n p \n=\n \n1000\n,\n rho \n=\n \n0\n,\n exposed \n=\n \nFALSE\n,\n\n                modProportions \n=\n \nc\n(\n0.15\n,\n0.15\n,\n0.15\n,\n0.15\n,\n0.15\n,\n0.25\n),\n\n                minCor \n=\n \n0.01\n,\n\n                maxCor \n=\n \n1\n,\n\n                corPower \n=\n \n1\n,\n\n                propNegativeCor \n=\n \n0.3\n,\n\n                backgroundNoise \n=\n \n0.5\n,\n\n                signed \n=\n \nFALSE\n,\n\n                leaveOut \n=\n \n1\n:\n4\n)\n\n\n\n\n\n\n##\n\n##  simulateDatExpr: simulating 1000 genes in 5 modules.\n\n\n\n\n\nd1 \n<-\n s_modules\n(\nn \n=\n \n100\n,\n p \n=\n \n1000\n,\n rho \n=\n \n0.9\n,\n exposed \n=\n \nTRUE\n,\n\n                modProportions \n=\n \nc\n(\n0.15\n,\n0.15\n,\n0.15\n,\n0.15\n,\n0.15\n,\n0.25\n),\n\n                minCor \n=\n \n0.4\n,\n\n                maxCor \n=\n \n1\n,\n\n                corPower \n=\n \n0.3\n,\n\n                propNegativeCor \n=\n \n0.3\n,\n\n                backgroundNoise \n=\n \n0.5\n,\n\n                signed \n=\n \nFALSE\n)\n\n\n\n\n\n\n##  simulateDatExpr: simulating 1000 genes in 5 modules.\n\n\n\n\n\n# get the true cluster labels\n\ntruemodule1 \n<-\n d1\n$\nsetLabels\n\ntable\n(\ntruemodule1\n)\n\n\n\n\n\n\n## truemodule1\n##   0   1   2   3   4   5 \n## 250 150 150 150 150 150\n\n\n\n\n\nNext we create the design matrix and label it. Note that the rows are\nthe subjects and the columns are the genes. The first 100 rows\ncorrespond to the unexposed subjects, and the next 100 subjects\ncorrespond to the exposed subjects:\n\n\npacman\n::\np_load\n(\nmagrittr\n)\n\n\nX \n<-\n \nrbind\n(\nd0\n$\ndatExpr\n,\n d1\n$\ndatExpr\n)\n \n%>%\n\n  magrittr\n::\nset_colnames\n(\npaste0\n(\n\"Gene\"\n,\n \n1\n:\n1000\n))\n \n%>%\n\n  magrittr\n::\nset_rownames\n(\npaste0\n(\n\"Subject\"\n,\n1\n:\n200\n))\n\n\n\n\n\n\nHere we used the \npheatmap\n and \nviridis\n packages to show the\ncorrelation matrices of the genes stratified by exposure status. The\nfirst figure corresponds to the unexposed \\( (E=0) \\) subjects, and\nthe second figure corresponds to the exposed \\( (E=1) \\) subjects:\n\n\npacman\n::\np_load\n(\npheatmap\n)\n\npacman\n::\np_load\n(\nviridis\n)\n\n\npheatmap\n::\npheatmap\n(\ncor\n(\nX\n[\n1\n:\n100\n,]),\n\n                   show_rownames \n=\n \nF\n,\n \n                   show_colnames \n=\n \nF\n,\n \n                   color \n=\n viridis\n(\n100\n))\n\n\npheatmap\n::\npheatmap\n(\ncor\n(\nX\n[\n101\n:\n200\n,]),\n\n                   show_rownames \n=\n \nF\n,\n \n                   show_colnames \n=\n \nF\n,\n \n                   color \n=\n viridis\n(\n100\n))\n\n\n\n\n\n\n\n\nThe response\n\u00b6\n\n\nThe first three simulation scenarios differ in how the linear predictor\n\\( Y^* \\) is defined, and also in the choice of regression model\nused to fit the data. In simulations 1 and 2 we use lasso (Tibshirani\n1996) and elasticnet (Zou 2005) to fit linear models; then we use MARS\n(Friedman 1991) in simulation 3 to estimate non-linear effects.\nSimulations 4, 5 and 6 use the GLM version of these models,\nrespectively, since the responses are binary.\n\n\nLinear Relationship\n\u00b6\n\n\nFor simulations 1 and 2 we used the \ns_generate_data\n function to\ngenerate linear relationships beteween the response and genes, of the\nform:\n\n\n\n\n Y^* = \\sum_{\\substack{j\\in \\left\\lbrace 1, \\ldots, 50 \\right\\rbrace\\\\ j \\in \\textrm{ red, green block}}}  \\beta_j X_j + \\beta_E E \n\nwhere \\( \\beta_j \\sim \\textrm{Unif}\\left[ 0.9,1.1\\right] \\) and \\(\n\\beta_E = 2 \\). That is, only the first 50 predictors of both the red\nand green blocks are active. In this setting, only the main effects\nmodel is being fit to the simulated data.\n\n\nWe used the \ns_generate_data\n with the \ninclude_interaction = TRUE\n\nargument to generate responses of the form:\n\n\n\n\n\nY^* = \\sum_{\\substack{j\\in \\left\\lbrace 1, \\ldots, 50 \\right\\rbrace\\\\ j \\in \\textrm{ red, green block}}} \\beta_j X_j + \\alpha_{j} X_j E + \\beta_E E \n\n\n\n\n\nwhere \n \\beta_j \\sim \\textrm{Unif}\\left[ 0.9,1.1\\right] \n\n\n \\alpha_{j} \\sim \\textrm{Unif}\\left[ 0.4,0.6\\right] \n\n\n \\beta_E = 2 \n In this setting, both the main effects and their\ninteractions with E are being fit to the simulated data.\n\n\nIn this example we generate a response which depends on both the main\neffects and their interactions with E. We first generate the true \\(\n\\beta \\) vector:\n\n\nbetaMainEffect \n<-\n \nvector\n(\n\"double\"\n,\n length \n=\n \n1000\n)\n\nbetaMainInteractions \n<-\n \nvector\n(\n\"double\"\n,\n length \n=\n \n1000\n)\n\n\n\n# the first 25 in the 3rd block are active\n\nbetaMainEffect\n[\nwhich\n(\ntruemodule1 \n%in%\n \n3\n)[\n1\n:\n50\n]]\n \n<-\n runif\n(\n50\n,\n \n0.9\n,\n \n1.1\n)\n\n\n\n# the first 25 in the 4th block are active\n\nbetaMainEffect\n[\nwhich\n(\ntruemodule1 \n%in%\n \n4\n)[\n1\n:\n50\n]]\n \n<-\n runif\n(\n50\n,\n \n0.9\n,\n \n1.1\n)\n\n\n\n# the interaction effects\n\nbetaMainInteractions\n[\nwhich\n(\nbetaMainEffect\n!=\n0\n)]\n \n<-\n runif\n(\n50\n,\n \n0.4\n,\n \n0.6\n)\n\n\n\n# the environment effect\n\nbetaE \n<-\n \n2\n\n\n\n# the total beta vector\n\nbeta \n<-\n \nc\n(\nbetaMainEffect\n,\n betaE\n,\n betaMainInteractions\n)\n\n\n\n\n\n\nNext we run the \ns_generate_data\n function to get the necessary results\nfor the analysis step of the simulation study. This function creates a\ntraining and a test set of equal size by evenly divinding the subjects\nsuch that there are an equal number of exposed and unexposed in both\ntraining and test sets.\n\n\nThere are several choices to make here, but these are the most important\narguments:\n\n\n\n\ncluster_distance\n: How should the genes, ignoring the exposure\n    status of the individuals, be clustered? We choose the \\( TOM \\)\n    matrix based on all subjects.\n\n\neclust_distance\n: How should the genes, accounting for the exposure\n    status of the individuals, be clustered? We choose the difference of\n    the exposure sensitive TOM matrices: \\( TOM(X_{\\textrm{diff}}) =\n    |TOM_{E=1} - TOM_{E=0}| \\)\n\n\ncut_method\n: How should the number of clusters be determined? We\n    choose the \ndynamicTreeCut::cutreeDynamic()\n algorithm which\n    automatically selects the number of clusters.\n\n\n\n\nresult \n<-\n s_generate_data\n(\np \n=\n \n1000\n,\n \n                          X \n=\n X\n,\n\n                          beta \n=\n \nbeta\n,\n\n                          include_interaction \n=\n \nTRUE\n,\n\n                          cluster_distance \n=\n \n\"tom\"\n,\n\n                          n \n=\n \n200\n,\n \n                          n0 \n=\n \n100\n,\n\n                          eclust_distance \n=\n \n\"difftom\"\n,\n\n                          signal_to_noise_ratio \n=\n \n1\n,\n\n                          distance_method \n=\n \n\"euclidean\"\n,\n\n                          cluster_method \n=\n \n\"hclust\"\n,\n\n                          cut_method \n=\n \n\"dynamic\"\n,\n\n                          agglomeration_method \n=\n \n\"average\"\n,\n\n                          nPC \n=\n \n1\n)\n\n\n\n\n\n\n## Creating data and simulating response\n\n## Calculating similarity matrices\n\n## TOM calculation: adjacency..\n## adjacency: replaceMissing: 0\n## ..will not use multithreading.\n##  Fraction of slow calculations: 0.000000\n## ..connectivity..\n## ..matrix multiplication..\n## ..normalization..\n## ..done.\n## TOM calculation: adjacency..\n## adjacency: replaceMissing: 0\n## ..will not use multithreading.\n##  Fraction of slow calculations: 0.000000\n## ..connectivity..\n## ..matrix multiplication..\n## ..normalization..\n## ..done.\n## TOM calculation: adjacency..\n## adjacency: replaceMissing: 0\n## ..will not use multithreading.\n##  Fraction of slow calculations: 0.000000\n## ..connectivity..\n## ..matrix multiplication..\n## ..normalization..\n## ..done.\n\n## Creating CV folds from training data\n\n## Calculating number of clusters based on tom using hclust with average\n##                   linkage and the dynamic to determine the number of clusters\n\n##  ..cutHeight not given, setting it to 0.999  ===>  99% of the (truncated) height range in dendro.\n##  ..done.\n\n## Calculating number of environment clusters based on  difftom\n\n##  ..cutHeight not given, setting it to 2.86  ===>  99% of the (truncated) height range in dendro.\n##  ..done.\n\n## There are 2 clusters derived from the tom similarity matrix\n\n## There are 10 clusters derived from the difftom environment similarity matrix\n\n## There are a total of 12 clusters derived from the tom\n##                   similarity matrix and the difftom environment similarity matrix\n\n\n\n\n\nnames\n(\nresult\n)\n\n\n\n\n\n\n##  [1] \"beta_truth\"              \"similarity\"             \n##  [3] \"similarityEclust\"        \"DT\"                     \n##  [5] \"Y\"                       \"X0\"                     \n##  [7] \"X1\"                      \"X_train\"                \n##  [9] \"X_test\"                  \"Y_train\"                \n## [11] \"Y_test\"                  \"DT_train\"               \n## [13] \"DT_test\"                 \"S0\"                     \n## [15] \"n_clusters_All\"          \"n_clusters_Eclust\"      \n## [17] \"n_clusters_Addon\"        \"clustersAll\"            \n## [19] \"clustersAddon\"           \"clustersEclust\"         \n## [21] \"gene_groups_inter\"       \"gene_groups_inter_Addon\"\n## [23] \"tom_train_all\"           \"tom_train_diff\"         \n## [25] \"tom_train_e1\"            \"tom_train_e0\"           \n## [27] \"corr_train_all\"          \"corr_train_diff\"        \n## [29] \"corr_train_e1\"           \"corr_train_e0\"          \n## [31] \"fisherScore\"             \"corScor\"                \n## [33] \"mse_null\"                \"DT_train_folds\"         \n## [35] \"X_train_folds\"           \"Y_train_folds\"\n\n\n\n\n\nNon-Linear Relationship\n\u00b6\n\n\nWe used the \ns_generate_data_mars\n function to generate non-linear\neffects of the predictors on the phenotype, of the form:\n\n\n\n\nThe \ns_generate_data_mars\n works exactly the same way as the\n\ns_generate_data\n function. The only difference is that the\n\ns_generate_data_mars\n calls the \ns_response_mars\n function to generate\nthe response, whereas the \ns_generate_data\n function calls the\n\ns_response\n function to generate the response.\n\n\nFitting Functions\n\u00b6\n\n\nIn our paper, we compare three general approaches as detailed in the\ntable below:\n\n\n\n\nThere are 4 fitting functions corresponding to the approaches outlined\nin the table above, specifically made to be used with the simulated\ndata:\n\n\n\n\n\n\n\n\n\nfunction.name\n\n\n\n\nGeneral.Approach\n\n\n\n\nmodel\n\n\n\n\n\n\n\n\n\n\n\n\ns_pen_separate\n\n\n\n\nSEPARATE\n\n\n\n\nlasso, elasticnet, mcp, scad\n\n\n\n\n\n\n\n\ns_pen_clust\n\n\n\n\nCLUST, ECLUST\n\n\n\n\nlasso, elasticnet, mcp, scad\n\n\n\n\n\n\n\n\ns_mars_separate\n\n\n\n\nSEPARATE\n\n\n\n\nMARS\n\n\n\n\n\n\n\n\ns_mars_clust\n\n\n\n\nCLUST, ECLUST\n\n\n\n\nMARS\n\n\n\n\n\n\n\n\n\n\nIn this example we fit a lasso to the clusters from the ECLUST method.\nThe key argument here is the \ngene_groups\n. We provide\n\nresult[[\"clustersAddon\"]]\n to the \ngene_groups\n function because it is\nthe clustering result using the environment information. If we wanted to\nrun the CLUST method, then we would provide \nresult[[\"clustersAll\"]]\n to\nthe \ngene_groups\n argument, because \nresult[[\"clustersAll\"]]\n is the\nclustering result from ignoring the environment information. We also\nspecify \nsummary = \"pc\"\n and \nmodel = \"lasso\"\n to specify that we want\nto use the 1st PC as the cluster representation and fit a lasso model to\nthose clusters and their interaction with \nE\n (as specified by the\n\ninclude_interaction = TRUE\n argument)\n\n\n# Provide ECLUST clustering results to the gene_groups argument\n\npen_res \n<-\n s_pen_clust\n(\nx_train \n=\n result\n[[\n\"X_train\"\n]],\n\n                       x_test \n=\n result\n[[\n\"X_test\"\n]],\n\n                       y_train \n=\n result\n[[\n\"Y_train\"\n]],\n\n                       y_test \n=\n result\n[[\n\"Y_test\"\n]],\n\n                       s0 \n=\n result\n[[\n\"S0\"\n]],\n\n                       gene_groups \n=\n result\n[[\n\"clustersAddon\"\n]],\n\n                       summary \n=\n \n\"pc\"\n,\n\n                       model \n=\n \n\"lasso\"\n,\n\n                       exp_family \n=\n \n\"gaussian\"\n,\n\n                       clust_type \n=\n \n\"ECLUST\"\n,\n\n                       include_interaction \n=\n \nTRUE\n)\n\n\n\n\n\n\n## Summary measure: pc, Model: lasso, Cluster Type: ECLUST\n\n\n\n\n\nunlist\n(\npen_res\n)\n\n\n\n\n\n\n##                ECLUST_pc_lasso_yes_mse \n##                           1.573582e+03 \n##               ECLUST_pc_lasso_yes_RMSE \n##                           3.966840e+01 \n##               ECLUST_pc_lasso_yes_Shat \n##                           2.060000e+02 \n##                ECLUST_pc_lasso_yes_TPR \n##                           4.378109e-01 \n##                ECLUST_pc_lasso_yes_FPR \n##                           6.555556e-02 \n##    ECLUST_pc_lasso_yes_CorrectSparsity \n##                           8.845577e-01 \n##    ECLUST_pc_lasso_yes_CorrectZeroMain \n##                           9.600000e-01 \n##   ECLUST_pc_lasso_yes_CorrectZeroInter \n##                           9.088889e-01 \n##  ECLUST_pc_lasso_yes_IncorrectZeroMain \n##                           1.287129e-01 \n## ECLUST_pc_lasso_yes_IncorrectZeroInter \n##                           1.000000e+00 \n##          ECLUST_pc_lasso_yes_nclusters \n##                           1.200000e+01\n\n\n\n\n\nThe table below describes the measures of performance:",
            "title": "Simulations"
        },
        {
            "location": "/simulation/#simulation-functions-s_",
            "text": "The  s_  functions were used to conduct the simulation studies in the Bhatnagar et.al (2017+) . The  s_modules ,  s_generate_data  and s_generate_data_mars  are the main functions to generate the simulated\ndata.  In the paper we designed 6 simulation scenarios that are constructed to\nillustrate different kinds of relationships between the variables and\nthe response. For all scenarios, we have created high dimensional data\nsets with \\( p \\) predictors, and sample sizes of \\( n \\). We also\nassume that we have two data sets for each simulation - a training data\nset where the parameters are estimated, and a testing data set where\nprediction performance is evaluated, each of equal size \\( n_{train} =\nn_{test} \\). The number of subjects who were exposed (\\( n_{E=1}=100\n\\)) and unexposed (\\( n_{E=0}=100 \\)) and the number of truly\nassociated parameters (\\( 0.10 * p \\)) remain fixed across the 6\nsimulation scenarios.  Let    Y = Y^* + k \\cdot \\varepsilon    where \\( Y ^ * \\) is the linear predictor, the error term \\(\n\\varepsilon \\) is generated from a standard normal distribution, and\n\\( k \\) is chosen such that the signal-to-noise ratio  SNR = \\left(Var(Y^*) \\over Var(\\varepsilon)\\right)   is 0.2, 1 and 2\n(e.g. the variance of the response variable \\( Y \\) due to \\(\n\\varepsilon \\) is \\( 1/SNR \\) of the variance of \\( Y \\) due to \\(\nY^* \\)).",
            "title": "Simulation functions (s_)"
        },
        {
            "location": "/simulation/#the-design-matrix",
            "text": "We generate covariate data in 5 blocks using the  s_modules  function\nwhich is a wrapper of the  simulateDatExpr  function from the  WGCNA \npackage in  R  (version 1.51). This generates data from a latent vector:\nfirst a seed vector is simulated, then covariates are generated with\nvarying degree of correlation with the seed vector in a given block.  For the unexposed observations (\\( E=0 \\)), only the predictors in the\nyellow block were simulated with correlation, while all other covariates\nwere independent within and between blocks. For the exposed observations\n(\\( E=1 \\)), all 5 blocks contained predictors that are correlated.  For simplicity, we will refer to the simulated data as gene expression\ndata, with each column of the design matrix being a gene. First we\ngenerate gene expression data for \\( p=1000 \\) genes, independently\nfor the 100 unexposed ( d0 ) and 100 exposed ( d1 ) subjects using the s_modules  function. The exposed subjects are meant to have correlated\ngenes while the unexposed subject don't. The  modProportions  argument\nis a numeric vector with length equal the number of modules you want to\ngenerate plus one, containing fractions of the total number of genes to\nbe put into each of the modules and into the \"grey module\", which means\ngenes not related to any of the modules. In the following examples we\ngenerate 5 modules of equal size (15% of \\( p \\) each module) plus 1\n\"grey\" module (25% of \\( p \\))  pacman :: p_load ( eclust ) \nd0  <-  s_modules ( n  =   100 ,  p  =   1000 ,  rho  =   0 ,  exposed  =   FALSE , \n                modProportions  =   c ( 0.15 , 0.15 , 0.15 , 0.15 , 0.15 , 0.25 ), \n                minCor  =   0.01 , \n                maxCor  =   1 , \n                corPower  =   1 , \n                propNegativeCor  =   0.3 , \n                backgroundNoise  =   0.5 , \n                signed  =   FALSE , \n                leaveOut  =   1 : 4 )   ##\n\n##  simulateDatExpr: simulating 1000 genes in 5 modules.  d1  <-  s_modules ( n  =   100 ,  p  =   1000 ,  rho  =   0.9 ,  exposed  =   TRUE , \n                modProportions  =   c ( 0.15 , 0.15 , 0.15 , 0.15 , 0.15 , 0.25 ), \n                minCor  =   0.4 , \n                maxCor  =   1 , \n                corPower  =   0.3 , \n                propNegativeCor  =   0.3 , \n                backgroundNoise  =   0.5 , \n                signed  =   FALSE )   ##  simulateDatExpr: simulating 1000 genes in 5 modules.  # get the true cluster labels \ntruemodule1  <-  d1 $ setLabels table ( truemodule1 )   ## truemodule1\n##   0   1   2   3   4   5 \n## 250 150 150 150 150 150  Next we create the design matrix and label it. Note that the rows are\nthe subjects and the columns are the genes. The first 100 rows\ncorrespond to the unexposed subjects, and the next 100 subjects\ncorrespond to the exposed subjects:  pacman :: p_load ( magrittr ) \n\nX  <-   rbind ( d0 $ datExpr ,  d1 $ datExpr )   %>% \n  magrittr :: set_colnames ( paste0 ( \"Gene\" ,   1 : 1000 ))   %>% \n  magrittr :: set_rownames ( paste0 ( \"Subject\" , 1 : 200 ))   Here we used the  pheatmap  and  viridis  packages to show the\ncorrelation matrices of the genes stratified by exposure status. The\nfirst figure corresponds to the unexposed \\( (E=0) \\) subjects, and\nthe second figure corresponds to the exposed \\( (E=1) \\) subjects:  pacman :: p_load ( pheatmap ) \npacman :: p_load ( viridis ) \n\npheatmap :: pheatmap ( cor ( X [ 1 : 100 ,]), \n                   show_rownames  =   F ,  \n                   show_colnames  =   F ,  \n                   color  =  viridis ( 100 )) \n\npheatmap :: pheatmap ( cor ( X [ 101 : 200 ,]), \n                   show_rownames  =   F ,  \n                   show_colnames  =   F ,  \n                   color  =  viridis ( 100 ))",
            "title": "The Design Matrix"
        },
        {
            "location": "/simulation/#the-response",
            "text": "The first three simulation scenarios differ in how the linear predictor\n\\( Y^* \\) is defined, and also in the choice of regression model\nused to fit the data. In simulations 1 and 2 we use lasso (Tibshirani\n1996) and elasticnet (Zou 2005) to fit linear models; then we use MARS\n(Friedman 1991) in simulation 3 to estimate non-linear effects.\nSimulations 4, 5 and 6 use the GLM version of these models,\nrespectively, since the responses are binary.",
            "title": "The response"
        },
        {
            "location": "/simulation/#linear-relationship",
            "text": "For simulations 1 and 2 we used the  s_generate_data  function to\ngenerate linear relationships beteween the response and genes, of the\nform:    Y^* = \\sum_{\\substack{j\\in \\left\\lbrace 1, \\ldots, 50 \\right\\rbrace\\\\ j \\in \\textrm{ red, green block}}}  \\beta_j X_j + \\beta_E E  \nwhere \\( \\beta_j \\sim \\textrm{Unif}\\left[ 0.9,1.1\\right] \\) and \\(\n\\beta_E = 2 \\). That is, only the first 50 predictors of both the red\nand green blocks are active. In this setting, only the main effects\nmodel is being fit to the simulated data.  We used the  s_generate_data  with the  include_interaction = TRUE \nargument to generate responses of the form:   \nY^* = \\sum_{\\substack{j\\in \\left\\lbrace 1, \\ldots, 50 \\right\\rbrace\\\\ j \\in \\textrm{ red, green block}}} \\beta_j X_j + \\alpha_{j} X_j E + \\beta_E E    where   \\beta_j \\sim \\textrm{Unif}\\left[ 0.9,1.1\\right]    \\alpha_{j} \\sim \\textrm{Unif}\\left[ 0.4,0.6\\right]    \\beta_E = 2   In this setting, both the main effects and their\ninteractions with E are being fit to the simulated data.  In this example we generate a response which depends on both the main\neffects and their interactions with E. We first generate the true \\(\n\\beta \\) vector:  betaMainEffect  <-   vector ( \"double\" ,  length  =   1000 ) \nbetaMainInteractions  <-   vector ( \"double\" ,  length  =   1000 )  # the first 25 in the 3rd block are active \nbetaMainEffect [ which ( truemodule1  %in%   3 )[ 1 : 50 ]]   <-  runif ( 50 ,   0.9 ,   1.1 )  # the first 25 in the 4th block are active \nbetaMainEffect [ which ( truemodule1  %in%   4 )[ 1 : 50 ]]   <-  runif ( 50 ,   0.9 ,   1.1 )  # the interaction effects \nbetaMainInteractions [ which ( betaMainEffect != 0 )]   <-  runif ( 50 ,   0.4 ,   0.6 )  # the environment effect \nbetaE  <-   2  # the total beta vector \nbeta  <-   c ( betaMainEffect ,  betaE ,  betaMainInteractions )   Next we run the  s_generate_data  function to get the necessary results\nfor the analysis step of the simulation study. This function creates a\ntraining and a test set of equal size by evenly divinding the subjects\nsuch that there are an equal number of exposed and unexposed in both\ntraining and test sets.  There are several choices to make here, but these are the most important\narguments:   cluster_distance : How should the genes, ignoring the exposure\n    status of the individuals, be clustered? We choose the \\( TOM \\)\n    matrix based on all subjects.  eclust_distance : How should the genes, accounting for the exposure\n    status of the individuals, be clustered? We choose the difference of\n    the exposure sensitive TOM matrices: \\( TOM(X_{\\textrm{diff}}) =\n    |TOM_{E=1} - TOM_{E=0}| \\)  cut_method : How should the number of clusters be determined? We\n    choose the  dynamicTreeCut::cutreeDynamic()  algorithm which\n    automatically selects the number of clusters.   result  <-  s_generate_data ( p  =   1000 ,  \n                          X  =  X , \n                          beta  =   beta , \n                          include_interaction  =   TRUE , \n                          cluster_distance  =   \"tom\" , \n                          n  =   200 ,  \n                          n0  =   100 , \n                          eclust_distance  =   \"difftom\" , \n                          signal_to_noise_ratio  =   1 , \n                          distance_method  =   \"euclidean\" , \n                          cluster_method  =   \"hclust\" , \n                          cut_method  =   \"dynamic\" , \n                          agglomeration_method  =   \"average\" , \n                          nPC  =   1 )   ## Creating data and simulating response\n\n## Calculating similarity matrices\n\n## TOM calculation: adjacency..\n## adjacency: replaceMissing: 0\n## ..will not use multithreading.\n##  Fraction of slow calculations: 0.000000\n## ..connectivity..\n## ..matrix multiplication..\n## ..normalization..\n## ..done.\n## TOM calculation: adjacency..\n## adjacency: replaceMissing: 0\n## ..will not use multithreading.\n##  Fraction of slow calculations: 0.000000\n## ..connectivity..\n## ..matrix multiplication..\n## ..normalization..\n## ..done.\n## TOM calculation: adjacency..\n## adjacency: replaceMissing: 0\n## ..will not use multithreading.\n##  Fraction of slow calculations: 0.000000\n## ..connectivity..\n## ..matrix multiplication..\n## ..normalization..\n## ..done.\n\n## Creating CV folds from training data\n\n## Calculating number of clusters based on tom using hclust with average\n##                   linkage and the dynamic to determine the number of clusters\n\n##  ..cutHeight not given, setting it to 0.999  ===>  99% of the (truncated) height range in dendro.\n##  ..done.\n\n## Calculating number of environment clusters based on  difftom\n\n##  ..cutHeight not given, setting it to 2.86  ===>  99% of the (truncated) height range in dendro.\n##  ..done.\n\n## There are 2 clusters derived from the tom similarity matrix\n\n## There are 10 clusters derived from the difftom environment similarity matrix\n\n## There are a total of 12 clusters derived from the tom\n##                   similarity matrix and the difftom environment similarity matrix  names ( result )   ##  [1] \"beta_truth\"              \"similarity\"             \n##  [3] \"similarityEclust\"        \"DT\"                     \n##  [5] \"Y\"                       \"X0\"                     \n##  [7] \"X1\"                      \"X_train\"                \n##  [9] \"X_test\"                  \"Y_train\"                \n## [11] \"Y_test\"                  \"DT_train\"               \n## [13] \"DT_test\"                 \"S0\"                     \n## [15] \"n_clusters_All\"          \"n_clusters_Eclust\"      \n## [17] \"n_clusters_Addon\"        \"clustersAll\"            \n## [19] \"clustersAddon\"           \"clustersEclust\"         \n## [21] \"gene_groups_inter\"       \"gene_groups_inter_Addon\"\n## [23] \"tom_train_all\"           \"tom_train_diff\"         \n## [25] \"tom_train_e1\"            \"tom_train_e0\"           \n## [27] \"corr_train_all\"          \"corr_train_diff\"        \n## [29] \"corr_train_e1\"           \"corr_train_e0\"          \n## [31] \"fisherScore\"             \"corScor\"                \n## [33] \"mse_null\"                \"DT_train_folds\"         \n## [35] \"X_train_folds\"           \"Y_train_folds\"",
            "title": "Linear Relationship"
        },
        {
            "location": "/simulation/#non-linear-relationship",
            "text": "We used the  s_generate_data_mars  function to generate non-linear\neffects of the predictors on the phenotype, of the form:   The  s_generate_data_mars  works exactly the same way as the s_generate_data  function. The only difference is that the s_generate_data_mars  calls the  s_response_mars  function to generate\nthe response, whereas the  s_generate_data  function calls the s_response  function to generate the response.",
            "title": "Non-Linear Relationship"
        },
        {
            "location": "/simulation/#fitting-functions",
            "text": "In our paper, we compare three general approaches as detailed in the\ntable below:   There are 4 fitting functions corresponding to the approaches outlined\nin the table above, specifically made to be used with the simulated\ndata:     \nfunction.name  \nGeneral.Approach  \nmodel      \ns_pen_separate  \nSEPARATE  \nlasso, elasticnet, mcp, scad    \ns_pen_clust  \nCLUST, ECLUST  \nlasso, elasticnet, mcp, scad    \ns_mars_separate  \nSEPARATE  \nMARS    \ns_mars_clust  \nCLUST, ECLUST  \nMARS     In this example we fit a lasso to the clusters from the ECLUST method.\nThe key argument here is the  gene_groups . We provide result[[\"clustersAddon\"]]  to the  gene_groups  function because it is\nthe clustering result using the environment information. If we wanted to\nrun the CLUST method, then we would provide  result[[\"clustersAll\"]]  to\nthe  gene_groups  argument, because  result[[\"clustersAll\"]]  is the\nclustering result from ignoring the environment information. We also\nspecify  summary = \"pc\"  and  model = \"lasso\"  to specify that we want\nto use the 1st PC as the cluster representation and fit a lasso model to\nthose clusters and their interaction with  E  (as specified by the include_interaction = TRUE  argument)  # Provide ECLUST clustering results to the gene_groups argument \npen_res  <-  s_pen_clust ( x_train  =  result [[ \"X_train\" ]], \n                       x_test  =  result [[ \"X_test\" ]], \n                       y_train  =  result [[ \"Y_train\" ]], \n                       y_test  =  result [[ \"Y_test\" ]], \n                       s0  =  result [[ \"S0\" ]], \n                       gene_groups  =  result [[ \"clustersAddon\" ]], \n                       summary  =   \"pc\" , \n                       model  =   \"lasso\" , \n                       exp_family  =   \"gaussian\" , \n                       clust_type  =   \"ECLUST\" , \n                       include_interaction  =   TRUE )   ## Summary measure: pc, Model: lasso, Cluster Type: ECLUST  unlist ( pen_res )   ##                ECLUST_pc_lasso_yes_mse \n##                           1.573582e+03 \n##               ECLUST_pc_lasso_yes_RMSE \n##                           3.966840e+01 \n##               ECLUST_pc_lasso_yes_Shat \n##                           2.060000e+02 \n##                ECLUST_pc_lasso_yes_TPR \n##                           4.378109e-01 \n##                ECLUST_pc_lasso_yes_FPR \n##                           6.555556e-02 \n##    ECLUST_pc_lasso_yes_CorrectSparsity \n##                           8.845577e-01 \n##    ECLUST_pc_lasso_yes_CorrectZeroMain \n##                           9.600000e-01 \n##   ECLUST_pc_lasso_yes_CorrectZeroInter \n##                           9.088889e-01 \n##  ECLUST_pc_lasso_yes_IncorrectZeroMain \n##                           1.287129e-01 \n## ECLUST_pc_lasso_yes_IncorrectZeroInter \n##                           1.000000e+00 \n##          ECLUST_pc_lasso_yes_nclusters \n##                           1.200000e+01  The table below describes the measures of performance:",
            "title": "Fitting Functions"
        },
        {
            "location": "/plots/",
            "text": "Plot Method for Object of class similarity\n\u00b6\n\n\nThere is a plot method for similarity matrices included in this package, though it is very specific to the simulated data only since the resulting plot annotates the true cluster membership of the genes. The plot uses the \npheatmap\n package for the heatmaps along with the \nviridis\n package for the color scheme so these packages need to be installed prior to using this function.\n\n\nThe plot method is for objects of class \nsimilarity\n. The following objects, which are outputs of the \ns_generate_data\n function, are objects of class \nsimilarity\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nobject.name\n\n\n\n\n\n\n\n\n\n\ntom_train_all\n\n\n\n\n\n\ntom_train_diff\n\n\n\n\n\n\ntom_train_e1\n\n\n\n\n\n\ntom_train_e0\n\n\n\n\n\n\ncorr_train_all\n\n\n\n\n\n\ncorr_train_diff\n\n\n\n\n\n\ncorr_train_e1\n\n\n\n\n\n\ncorr_train_e0\n\n\n\n\n\n\nfisherScore\n\n\n\n\n\n\ncorScor\n\n\n\n\n\n\n\n\n\nTo plot the heatmap of the similarity matrix, you need to provide it with the clustering tree, the cluster membership and the genes active in the response. In this example we plot the TOM matrix for the exposed subjects given by the \ntom_train_e1\n object. The resulting heatmap has annotations for the cluster membership and if the gene is active in the response:\n\n\n# check that the object is of class similarity\n\n\nclass\n(\nresult\n$\ntom_train_e1\n)\n\n\n\n\n\n\n## [1] \"matrix\"     \"similarity\"\n\n\n\n\n\n# get clustering tree\n\nhc \n<-\n hclust\n(\nas.dist\n(\n1\n \n-\n result\n$\ntom_train_e1\n),\n method \n=\n \n\"average\"\n)\n\n\nplot\n(\nresult\n$\ntom_train_e1\n,\n \n     truemodule \n=\n truemodule1\n,\n \n     cluster_rows \n=\n hc\n,\n \n     cluster_cols \n=\n hc\n,\n\n     active \n=\n \nas.numeric\n(\nbetaMainEffect\n!=\n0\n))",
            "title": "Heatmaps"
        },
        {
            "location": "/plots/#plot-method-for-object-of-class-similarity",
            "text": "There is a plot method for similarity matrices included in this package, though it is very specific to the simulated data only since the resulting plot annotates the true cluster membership of the genes. The plot uses the  pheatmap  package for the heatmaps along with the  viridis  package for the color scheme so these packages need to be installed prior to using this function.  The plot method is for objects of class  similarity . The following objects, which are outputs of the  s_generate_data  function, are objects of class  similarity :        object.name      tom_train_all    tom_train_diff    tom_train_e1    tom_train_e0    corr_train_all    corr_train_diff    corr_train_e1    corr_train_e0    fisherScore    corScor     To plot the heatmap of the similarity matrix, you need to provide it with the clustering tree, the cluster membership and the genes active in the response. In this example we plot the TOM matrix for the exposed subjects given by the  tom_train_e1  object. The resulting heatmap has annotations for the cluster membership and if the gene is active in the response:  # check that the object is of class similarity  class ( result $ tom_train_e1 )   ## [1] \"matrix\"     \"similarity\"  # get clustering tree \nhc  <-  hclust ( as.dist ( 1   -  result $ tom_train_e1 ),  method  =   \"average\" ) \n\nplot ( result $ tom_train_e1 ,  \n     truemodule  =  truemodule1 ,  \n     cluster_rows  =  hc ,  \n     cluster_cols  =  hc , \n     active  =   as.numeric ( betaMainEffect != 0 ))",
            "title": "Plot Method for Object of class similarity"
        }
    ]
}